# Copyright 2019 Akretion <raphael.reverdy@akretion.com>
# Copyright 2019 - TODAY, Brian McMaster, Open Source Integrators
# License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl).

from datetime import datetime, time

import pytz

from odoo import api, fields, models
from odoo.exceptions import ValidationError
from odoo.tools.translate import _


class ContractLine(models.Model):
    _inherit = "contract.line"

    fsm_recurring_id = fields.Many2one(
        "fsm.recurring",
        "FSM Recurring Order",
        index=True,
        readonly=True,
        help="Field Service Recurring Order generated by the sale order line",
    )

    fsm_direct_order_id = fields.Many2one(
        "fsm.order",
        "FSM Order",
        index=True,
        readonly=True,
        # only direct orders, not the ones generated by recurring order
        help="Field Service Order generated by the contract line",
    )

    fsm_order_ids = fields.One2many(
        comodel_name="fsm.order",
        inverse_name="contract_line_id",
        string="FSM Orders",
        index=True,
        readonly=True,
        copy=False,
        help="All FSM Orders linked to this contract line",
        # recurring and direct orders
    )
    fsm_location_id = fields.Many2one(
        string="FSM Location",
        comodel_name="fsm.location",
        copy=True,
        default=lambda x: x.contract_id.fsm_location_id,
    )
    fsm_frequency_set_id = fields.Many2one(
        "fsm.frequency.set",
        "Frequency Set",
        index=True,
        copy=True,
        help="Frequency of the service",
        domain=[("is_abstract", "=", True)],
    )
    invoice_policy = fields.Selection(
        [("order_smoothing_bill", "Planned fsm order smoothing bill"),
         ("delivery_not_smoothing", "Realised fsm order not smoothing bill"),
         ],
        string="Invoicing Policy",
        help="Planned fsm order smoothing bill: This means that the amount of invoice don't depends on the number of fsm order planned in the invoiced period.\n"
            "Realised fsm order not smoothing bill: This means that the amount of invoice depends on the number of fsm order Realised in the invoiced period.\n",
        default="order_smoothing_bill",
    )
    fsm_order_by_year_count = fields.Float(
        "Theoric Yearly order count",
        compute="_compute_tehoric_order_count",
        help="We need the theorical count of order by year"
        " To compute a avarage price for each order if the invoice is based on the number of realised order."
        " In deed, for some frequencies, the numbre of orders is depending on month. Some month we have "
        " 5 monday and 4 for others. The price payed each month is the same for each month "
        "despite the difference in the theoric number of orders.",
        store=True,
    )
    fsm_order_by_month_count = fields.Float(
        "Theoric Yearly order count", compute="_compute_tehoric_order_count", store=True
    )
    avg_price_unit_fsm_order = fields.Float(
        "Avg price for a fsm order", compute="_compute_avg_price_unit_fsm_order",
        store=True
    )


    @api.depends("fsm_frequency_set_id",
                 "fsm_frequency_set_id.fsm_frequency_ids",)
    def _compute_tehoric_order_count(self):
        date_start = fields.datetime.today()
        date_start = date_start.replace(**{"day": 1, "month": 1})
        date_end = fields.datetime.today()
        date_end = date_end.replace(**{"day": 31, "month": 12})
        for contract_line in self:
            contract_line.fsm_order_by_year_count = 0
            contract_line.fsm_order_by_month_count = 0
            if not contract_line.fsm_frequency_set_id:
                continue
            rrules = contract_line.fsm_frequency_set_id._get_rruleset(
                dtstart=date_start, until=date_end
            )
            contract_line.fsm_order_by_year_count = len([date for date in rrules])
            contract_line.fsm_order_by_month_count = (
                contract_line.fsm_order_by_year_count / 12.0
            )  # number of month a year

    @api.depends("price_unit", "fsm_order_by_month_count")
    def _compute_avg_price_unit_fsm_order(self):
        for contract_line in self:
            avg_order_by_month = contract_line.fsm_order_by_month_count
            contract_line.avg_price_unit_fsm_order = 0
            if avg_order_by_month:
                contract_line.avg_price_unit_fsm_order = (
                    contract_line.price_unit / avg_order_by_month
                )

    def _prepare_invoice_line(self, move_form):
        # add link fsm orders to invoice line
        res = super()._prepare_invoice_line(move_form)
        dates = self._get_period_to_invoice(
            self.last_date_invoiced, self.recurring_next_date
        )
        fsm_orders = self._invoiceable_fsm_order(*dates)
        if fsm_orders:
            res.update({"fsm_order_ids": [(6, 0, fsm_orders.ids)]})
            if self.invoice_policy == "delivery_not_smoothing":
                res.update({"name": self._insert_order_markers(dates[0], dates[1], invoiced_orders=fsm_orders)})
        price_unit = self.price_unit
        if self.invoice_policy == "delivery_not_smoothing":
            price_unit =  self.avg_price_unit_fsm_order
        res.update({"price_unit": price_unit})
        return res

    def _insert_order_markers(self, first_date_invoiced, last_date_invoiced,
                        invoiced_orders=None):
        self.ensure_one()
        lang_obj = self.env["res.lang"]
        lang = lang_obj.search([("code", "=", self.contract_id.partner_id.lang)])
        date_format = lang.date_format or "%m/%d/%Y"
        name = self._insert_markers(first_date_invoiced, last_date_invoiced)
        if invoiced_orders:
            name+= "\n"
            for order in invoiced_orders:
                name += "# " + order.name + " : " + order.scheduled_date_start.strftime(date_format)
        return name

    def _get_quantity_to_invoice(
        self, period_first_date, period_last_date, invoice_date
    ):
        # here we do not have link yet between invoice.line
        # and fsm orders
        self.ensure_one()
        quantity = 0
        if self.fsm_direct_order_id or self.fsm_recurring_id:
            # if self.invoice_policy == "order_not_smoothing_bill":
            #     quantity = self.fsm_frequency_set_id._get_theoretical_order_count_by_period(period_first_date, period_last_date)
            #elif
            if self.invoice_policy == "delivery_not_smoothing":
                quantity = len(
                    self._invoiceable_fsm_order(
                        period_first_date, period_last_date, invoice_date
                    )
                )
            else:
                quantity = self.quantity
        else:
            quantity = super()._get_quantity_to_invoice(
                period_first_date, period_last_date, invoice_date
            )
        return quantity

    def _invoiceable_fsm_order(self, period_first_date, period_last_date, invoice_date):
        invoiceable_stage_ids = self._get_invoiceable_stage()
        dom = [
            ("scheduled_date_start", ">=", period_first_date),
            ("scheduled_date_start", "<=", period_last_date),
        ] + self._get_invoiceable_order_domain()
        if invoiceable_stage_ids:
            dom.append(["stage_id", "in", invoiceable_stage_ids.ids])

        return self.env["fsm.order"].search(dom)

    def _get_realised_fsm_order(
        self, period_first_date, period_last_date, invoice_date
    ):
        """
        :param period_first_date:
        :param period_last_date:
        :param invoice_date:
        :return:
        fsm order plannified in the period and not realised
        """
        realised_ids = self._get_realised_stage()

        dom = [
            ("scheduled_date_start", ">=", period_first_date),
            ("scheduled_date_start", "<=", period_last_date),
        ]
        if realised_ids:
            dom.append(["stage_id", "in", realised_ids.ids])
        return self.env["fsm.order"].search(dom)

    def _get_invoiceable_stage(self):
        """
        overide this method to define invoiceable stage
        :return:
        """
        return self.env["fsm.stage"]._get_invoiceable_stage()

    def _get_realised_stage(self):
        """
        overide this method to define invoiceable stage
        :return:
        """
        return self.ref("fieldservice.fsm_stage_completed")

    def _get_invoiceable_order_domain(self):
        """
        overide this method to define more search cretaria for invoiceable
        fsm order
        :return:
        """
        return [    ("contract_line_id", "=", self.id),
            ("invoice_lines", "=", False),
        ]


    @api.model
    def create(self, values):
        line = super().create(values)
        line._field_service_generation()
        return line

    def write(self, vals):
        res = super().write(vals)
        self.update_fsm(vals)
        return res

    def update_fsm(self, vals):
        to_apply = {}
        if "date_start" in vals:
            to_apply["start_date"] = vals["date_start"]
        if "date_end" in vals:
            to_apply["end_date"] = vals["date_end"]
        if "fsm_location_id" in vals:
            to_apply["location_id"] = vals["fsm_location_id"]

        self.mapped("fsm_recurring_id").filtered(
            lambda recurring: recurring.state not in ("cancelled", "done")
        ).write(to_apply)

    def _fsm_create_fsm_common_prepare_values(self):
        location = self.fsm_location_id or self.contract_id.fsm_location_id
        if not location:
            raise ValidationError(_("No location defined on line (%s)" % self.name))
        return {
            "location_id": location.id,
            "description": self.name,
            "contract_line_id": self.id,
            "company_id": self.contract_id.company_id.id,
        }

    def _field_create_fsm_order_prepare_values(self):
        self.ensure_one()
        res = self._fsm_create_fsm_common_prepare_values()
        res["scheduled_date_start"] = self.date_start
        res["template_id"] = self.product_id.fsm_order_template_id.id
        return res

    def _field_create_fsm_recurring_prepare_values(self):
        self.ensure_one()
        template = self.product_id.fsm_recurring_template_id
        note = self.name
        if template.description:
            note += "\n " + template.description
        frequency_set = self.fsm_frequency_set_id or template.fsm_frequency_set_id
        res = self._fsm_create_fsm_common_prepare_values()

        def to_locale_datetime(some_date):
            tz = pytz.timezone(self._context.get("tz", self.env.user.tz or "UTC"))
            return tz.localize(
                datetime.combine(some_date, time())
            ).astimezone(pytz.UTC).replace(tzinfo=None)

        res["start_date"] = to_locale_datetime(self.date_start)
        res["end_date"] = to_locale_datetime(self.date_end)
        res["fsm_recurring_template_id"] = template.id
        res["description"] = note
        res["max_orders"] = template.max_orders
        res["fsm_abstract_frequency_set_id"] = frequency_set.id
        res["fsm_order_template_id"] = template.fsm_order_template_id.id
        return res

    def _field_create_fsm_order(self):
        """Generate fsm_order for the given line, and link it.
        :return a mapping with the line id and its linked fsm_order
        :rtype dict
        """
        result = {}
        for line in self:
            # create fsm_order
            values = line._field_create_fsm_order_prepare_values()
            fsm_order = self.env["fsm.order"].sudo().create(values)
            line.write({"fsm_direct_order_id": fsm_order.id})
            result[line.id] = fsm_order
        return result

    def _field_create_fsm_recurring(self):
        """Generate fsm_recurring for the given line, and link it.
        :return a mapping with the line id and its linked fsm_recurring
        :rtype dict
        """
        result = {}
        for line in self:
            # create fsm_recurring
            values = line._field_create_fsm_recurring_prepare_values()
            fsm_recurring = self.env["fsm.recurring"].sudo().create(values)
            # fsm_recurring.action_start()  # do not start yet
            line.write({"fsm_recurring_id": fsm_recurring.id})
            result[line.id] = fsm_recurring
        return result

    def _field_find_fsm_order(self):
        """Find the fsm_order generated by the lines. If no fsm_order
        linked, it will be created automatically.
        :return a mapping with the line id and its linked fsm_order
        :rtype dict
        """
        # one search for all lines
        fsm_orders = self.env["fsm.order"].search(
            [("contract_line_id", "in", self.ids)]
        )
        fsm_order_cl_mapping = {
            fsm_order.contract_line_id.id: fsm_order for fsm_order in fsm_orders
        }
        result = {}
        for line in self:
            # If the contract was confirmed, cancelled,
            # set to draft then confirmed,
            # avoid creating a new fsm_order.
            fsm_order = fsm_order_cl_mapping.get(line.id)
            # If not found, create one fsm_order for the line
            if not fsm_order:
                fsm_order = line._field_create_fsm_order()[line.id]
            result[line.id] = fsm_order
        return result

    def _field_find_fsm_recurring(self):
        """Find the fsm_recurring generated by the lines. If no
        fsm_recurring linked, it will be created automatically.
        :return a mapping with the line id and its linked
        fsm_recurring
        :rtype dict
        """
        # one search for all lines
        fsm_recurrings = self.env["fsm.recurring"].search(
            [("contract_line_id", "in", self.ids)]
        )
        fsm_recurring_cl_mapping = {
            fsm_recurring.contract_line_id.id: fsm_recurring
            for fsm_recurring in fsm_recurrings
        }
        result = {}
        for line in self:
            # If the contract was confirmed, cancelled,
            # set to draft then confirmed,
            # avoid creating a new fsm_recurring.
            fsm_recurring = fsm_recurring_cl_mapping.get(line.id)
            # If not found, create one fsm_recurring for the line
            if not fsm_recurring:
                fsm_recurring = line._field_create_fsm_recurring()[line.id]
            result[line.id] = fsm_recurring
        return result

    def _field_service_generation(self):
        """For service lines, create the field service order. If it already
        exists, it simply links the existing one to the line.
        """
        for line in self.filtered(
            lambda sol: sol.product_id.field_service_tracking
            == "based_on_sale_line_frequency"
        ):
            # create recurring order
            if line.fsm_frequency_set_id:
                line._field_find_fsm_recurring()
            else:
                line._field_find_fsm_order()
        for line in self.filtered(
            lambda sol: sol.product_id.field_service_tracking
            != "based_on_sale_line_frequency"
        ):
            # create order
            if line.product_id.field_service_tracking == "line":
                line._field_find_fsm_order()
            # create recurring order
            elif line.product_id.field_service_tracking == "recurring":
                line._field_find_fsm_recurring()
